{"Deletable":1,"EventName":"arima.tf","DomainId":-1,"UpdatedBy":null,"Lock":{"UserId":59,"Username":"h_khair95"},"Domain":{"DomainId":-1,"DomainName":"SystemDomain","DomainDescription":"","Active":1,"CreationDate":null,"CreatedBy":null},"EventDescription":" Enter EventDescription","EventId":224,"Groups":[66],"EventType":"Custom","UpdateDate":null,"EventParameters":[{"ParameterId":29866,"EventId":224,"ParameterName":"Code","ParameterValue":"/******************************************* Code Sample ******************************************** \n* Sensor.profile: object which includes all sensor profile properties\n* Sensor.reading: object which includes sensor readings\n* Sensor.cached: object which includes cached sensor readings if exist\n* FiringObject: object which includes information about firing event\n* FiringObject.type: value could be either monitor or timer or user\n* FiringObject.user: if exists it includes loggedIn user object (i.e. firingObject.user.username)\n* FiringObject.timer: if exists it includes firing timer info (i.e. firingObject.timer.TimerId)\n* FiringObject.monitor: if exists it includes firing monitor info (i.e. firingObject.monitor.MonitorId)\n*\n* Custom event should end with \n*    event.end(value) incase of success\n*    event.error(error message) incase of error\n*      add error example\n*\n*\n* \n******************************** Now It's Your Turn To Write Your Own Code *************************/  \n/*Enter Your Customized code*/\n//=======================utils===============================\nfunction DataListAddAsync(name, value) {\n  return new Promise((resolve, reject) => {\n      const dataListObj = {\n        name: name,\n        value: value,\n        insertAt: \"tail\"\n      }\n\n      ;\n      DataList.add(dataListObj, dataList_callback);\n\n      function dataList_callback(err, res) {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(res);\n      }\n    }\n\n  );\n}\n\nfunction DataListRemoveAsync(name, value) {\n  return new Promise((resolve, reject) => {\n      const opt = {\n        \"name\": name,\n        \"value\": value,\n        \"count\": \"0\"\n      };\n\n      DataList.remove(opt, dataList_callback);\n\n      function dataList_callback(err, res) {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(res);\n      }\n    }\n\n  );\n}\n\nfunction DataListgetAsync(name) {\n  return new Promise((resolve, reject) => {\n      const opt = {\n        \"name\": name\n      };\n\n      DataList.get(opt, dataList_callback);\n\n      function dataList_callback(err, res) {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(res)\n      }\n    }\n\n  );\n}\n\nfunction DataListupdateAsync(name, value, index) {\n  return new Promise((resolve, reject) => {\n      const opt = {\n        \"name\": name,\n        \"value\": value, // updated value\n        \"index\": index // updated index\n      };\n\n      DataList.update(opt, dataList_callback);\n\n      function dataList_callback(err, res) {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(res);\n      }\n    }\n\n  );\n}\n\n\nfunction SearchInAsync(query) {\n  return new Promise((resolve, reject) => {\n      // SearchIn(query, searchIn_callback);\n      ExecuteQueryModified(query, searchIn_callback, '');\n\n      function searchIn_callback(err, result) {\n        if (err) {\n          return reject(err);\n        }\n\n        // write your code here\n        resolve(result);\n      }\n    }\n\n  );\n}\n\n//=======================utils===============================\n\nconst tf = require(\"@tensorflow/tfjs\");\n\nclass LinearRegression {\n\n\t/**\n\t * Linear Model private fields\n\t */\n\t#shifts = 0;\n\t#modelName = \"\";\n\n\n\t/**\n\t * @param {number} shifts \n\t * @param {string} modelName \n\t */\n\tconstructor(shifts, modelName = null) {\n\t\tif (!(Number.isInteger(shifts) && shifts >= 0)) {\n\t\t\tthrow \"Error: `shifts` must be 0 or positive Integer\";\n\t\t}\n\t\tthis.#shifts = shifts;\n\t\tthis.#modelName = modelName;\n\t}\n\n\tget shifts() {\n\t\treturn this.#shifts;\n\t}\n\n\tget modelName() {\n\t\treturn this.#modelName;\n\t}\n\n\t/**\n\t * Start a Linear model training\n\t * @param {Array<number>} X \n\t * @param {object} params \n\t * \n\t * @returns {Promise<tf.History>}\n\t */\n\tfit(X, params, learningRate) {\n\t\tlet [features, labels] = this.shiftInput(X);\n\t\tconst sliceWindow = -1 * this.#shifts;\n\t\tthis._keptFeatures = X.slice(sliceWindow);\n\n\t\t// Build & compile Linear model\n\t\tconst inputShape = [features.shape[1]];\n\t\tconst optimizer = tf.train.adam(learningRate);\n\t\tconst lossFunction = \"meanSquaredError\";\n\t\tconst metrics = [tf.metrics.meanSquaredError];\n\t\tthis.#buildModel(inputShape, optimizer, lossFunction, metrics);\n\n\t\t// Start training of Linear model \n\t\treturn this.model.fit(features, labels, params);\n\t}\n\n\t/**\n\t * Predict values of a trained Linear model \n\t * X could be stepsNumber by default or features matrix when (usingFeatures=true)\n\t * @param {Array<number>|tfjs.Tensor|number} X \n\t * @param {Boolean} usingFeatures \n\t * \n\t * @returns {Array<number>}\n\t */\n\tpredictSync(X, usingFeatures = false) {\n\t\tif (usingFeatures) {\n\t\t\treturn this.model.predict(X).reshape([-1, 1]).arraySync();\n\t\t}\n\t\tlet res = [...this._keptFeatures];\n\t\tlet featureShape = [1, this.#shifts];\n\t\tconst sliceWindow = -1 * featureShape[1];\n\t\tif (this.#shifts <= 0) {\n\t\t\tfeatureShape = [-1];\n\t\t}\n\n\t\tfor (let s = 0; s < X; s++) {\n\t\t\tlet features = tf.tensor(res.slice(sliceWindow)).reshape(featureShape);\n\t\t\tlet yHat = this.model.predict(features).arraySync();\n\t\t\tres.push(yHat[0][0]);\n\t\t}\n\t\treturn res.slice(-X);\n\t}\n\n\t/**\n\t * Async Predict values of a trained Linear model \n\t * X could be stepsNumber by default or features matrix when (usingFeatures=true)\n\t * @param {Array<number>|tfjs.Tensor|number} X \n\t * @param {Boolean} usingFeatures \n\t * \n\t * @returns {Promise<Array<number>>}\n\t */\n\tpredict(X, usingFeatures = false) {\n\t\treturn Promise.resolve(this.predictSync(X, usingFeatures));\n\t}\n\n\t/**\n\t * Lag(shift) input data with order = this._shifts\n\t * @param {Array<number>} X \n\t * \n\t * @returns {Array<tf.Tensor>}\n\t */\n\tshiftInput(X) {\n\t\tif (this.#shifts == 0) {\n\t\t\treturn [\n\t\t\t\ttf.tensor(X).reshape([-1, 1]),\n\t\t\t\ttf.tensor(X).reshape([-1, 1])\n\t\t\t];\n\t\t}\n\t\tconst featureShape = [(X.length - this.#shifts), this.#shifts];\n\t\tconst labelShape = [-1, 1];\n\t\tlet labels = X.slice(this.#shifts);\n\t\tlet features = [];\n\t\tfor (let i = 1; i <= this.#shifts; i++) {\n\t\t\tfeatures.push(X.slice(this.#shifts - i, -i));\n\t\t}\n\n\t\treturn [\n\t\t\ttf.tensor(features).reshape(featureShape),\n\t\t\ttf.tensor(labels).reshape(labelShape)\n\t\t];\n\t}\n\n\t/**\n\t * Build single unit neural network that acts like Linear model\n\t * @param {Array<number>} inputShape \n\t * @param {Object} optimizer \n\t * @param {string} lossFunction \n\t * @param {Array<tf.metrics>|Array<Function>} metrics \n\t */\n\t#buildModel(inputShape,\n\t\toptimizer = tf.train.adam(1e-3),\n\t\tlossFunction = \"meanSquaredError\",\n\t\tmetrics = [tf.metrics.meanSquaredError]) {\n\n\t\t// Define input, which has a size of inputShape\n\t\tconst inputLayer = tf.input({ shape: inputShape });\n\n\t\t// Output dense layer uses linear activation.\n\t\tconst denseLayer1 = tf.layers.dense({\n\t\t\tunits: 1,\n\t\t\tkernelInitializer: 'zeros',\n\t\t\tbiasInitializer: 'zeros'\n\t\t});\n\n\t\t// Obtain the output symbolic tensor by applying the layers on the inputLayer.\n\t\tconst output = denseLayer1.apply(inputLayer);\n\n\t\t// Create the model based on the input shape.\n\t\tthis.model = tf.model({ inputs: inputLayer, outputs: output });\n\n\t\tthis.model.compile({\n\t\t\toptimizer: optimizer,\n\t\t\tloss: lossFunction,\n\t\t\tmetrics: metrics,\n\t\t});\n\t}\n\n}\n\n\nclass ARIMA {\n\t\n\t/**\n\t * ARIMA private fields\n\t */\n\t#p = 0;\n\t#d = 0;\n\t#q = 0;\n\t#arModel = {};\n\t#maModel = {};\n\n\t#DEFAULT_PARAMS = {\n\t\tepochs: 2048,\n\t\tshuffle: false, // time series is ordered\n\t\tvalidationSplit: .2, // cross validation 20% test -> validation score \n\t\tcallbacks: tf.callbacks.earlyStopping({\n\t\t\tmonitor: 'val_loss',\n\t\t\tpatience: 3\n\t\t})\n\t};\n\n\t#LEARNING_RATE = 1e-2;\n\n\t/**\n\t * \n\t * @param {number} p \n\t * @param {number} d \n\t * @param {number} q \n\t */\n\tconstructor(p, d, q) {\n\t\tthis.#p = p;\n\t\tthis.#d = d;\n\t\tthis.#q = q;\n\t\tthis.#arModel = new LinearRegression(this.#p, \"Auto Regression\");\n\t\tthis.#maModel = new LinearRegression(this.#q, \"Moving Average\");\n\t}\n\n\tget p() {\n\t\treturn this.#p;\n\t}\n\n\tget q() {\n\t\treturn this.#q;\n\t}\n\n\tget d() {\n\t\treturn this.#d;\n\t}\n\n\tget arModel() {\n\t\treturn this.#arModel;\n\t}\n\n\tget maModel() {\n\t\treturn this.#maModel;\n\t}\n\n\t/**\n\t * Differentiate data with order = d (stationarization step)\n\t * @param {Array<number>} X \n\t * \n\t * @returns {Array<number>}\n\t */\n\t#diff(X) {\n\t\tif (this.#d <= 0) {\n\t\t\treturn [...X];\n\t\t}\n\n\t\tlet diffX = [];\n\t\tfor (let d = this.#d; d < X.length; d++) {\n\t\t\tlet value = X[d] - X[d - this.#d];\n\t\t\tdiffX.push(value);\n\t\t}\n\t\treturn diffX;\n\t}\n\n\t/**\n\t * Invert differentiated data with order = d, De-Stationarization Step used for predicted values\n\t * @param {Array<number>} X \n\t * \n\t * @returns {Array<number>}\n\t */\n\t#inverseDiff(X) {\n\t\tif (this.#d <= 0) {\n\t\t\treturn X;\n\t\t}\n\t\tlet history = [...this._keptFeatures];\n\t\tlet res = [];\n\t\tfor (let i = 0; i < X.length; i++) {\n\t\t\tlet yHat = X[i];\n\t\t\tlet historyIdx = history.length - this.#d;\n\t\t\tlet historyVal = history[historyIdx];\n\t\t\tlet inverseVal = yHat + historyVal;\n\n\t\t\tres.push(inverseVal);\n\t\t\thistory.push(inverseVal);\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Start ARIMA model training\n\t * @param {Array<number>} X \n\t * @param {object} params \n\t * @param {number} learningRate \n\t * \n\t * @returns {Promise<tf.History>}\n\t */\n\tfit(X, params = this.#DEFAULT_PARAMS, learningRate=this.#LEARNING_RATE) { \n\t\t// inputs => neuron(AR) => neuron(MA) => output\n\t\t// pureJS: inputs (extract residuals) => model(AR,MA) => output\n\t\t// tfJS: inputs => model(AR, MA:const) model(AR:const, MA) => output\n\t\t// y_t = phi_p y_t-p + theta_q e_t-q;\n\t\t// e_t = y_t - y'_t (phi_p y_t-p + theta_q e_t-q=0)\n\t\tthis._keptFeatures = X;\n\t\tlet yPrime = this.#diff(X);\n\t\t// Fitting AutoRegression(AR) Part\n\t\treturn this.#arModel.fit(yPrime, params, learningRate).then(() => {\n\t\t\tlet [features, labels] = this.#arModel.shiftInput(yPrime);\n\n\t\t\t// Getting residuals (Noise) from AR\n\t\t\tlet arPreds = this.#arModel.predictSync(features, true); // predictSync of LinearRegression\n\t\t\tlet residuals = tf.sub(labels, arPreds).arraySync(); // observed\n\n\t\t\t// Fitting MovingAverage (MA) Part\n\t\t\treturn this.#maModel.fit(residuals, params, learningRate);\n\t\t});\n\t}\n\n\n\t/**\n\t * Predicts the next values by the number of steps given (stepsNumber)\n\t * @param {number} stepsNumber \n\t * \n\t * @returns {Array<number>}\n\t */\n\tpredictSync(stepsNumber=1) {\n\t\t// Predict AutoRegressive results (values)\n\t\tconst arPreds = this.#arModel.predictSync(stepsNumber);\n\n\t\t// Predict MovingAverage results (residuals)\n\t\tconst maPreds = this.#maModel.predictSync(stepsNumber);\n\n\t\t// Get AR output + MA output \n\t\tconst arimaPreds = tf.add(arPreds, maPreds).arraySync(); // Array(10) arr1[i]+arr2[i] \n\n\t\t// Inverse diff operation which happened before fitting the model\n\t\t// to get back prediction values in the same range of input data\n\t\tconst finalPreds = this.#inverseDiff(arimaPreds);\n\n\t\treturn finalPreds;\n\t}\n\n\t/**\n\t * Async Predicts the next values by the number of steps given (stepsNumber)\n\t * @param {number} stepsNumber \n\t * \n\t * @returns {Promise<Array>}\n\t */\n\tpredict(stepsNumber=1) {\n\t\treturn Promise.resolve(this.predictSync(stepsNumber));\n\t}\n\n\t/**\n\t * Evaluate model performance using a given metric\n\t * @param {tfjs.Tensor|Array} yTrue \n\t * @param {tfjs.Tesnor|Array} yPred \n\t * @param {function} fn \n\t * @returns \n\t */\n\tevaluate(yTrue, yPred, fn = tf.metrics.meanSquaredError) {\n\t\treturn fn(yTrue, yPred);\n\t}\n\n}\n\nmodule.exports = {\n\tARIMA: (p, d, q) => { return new ARIMA(p, d, q); },\n\tARMA: (p, q) => { return new ARIMA(p, q); },\n\tAR: (p) => { return new ARIMA(p, 0, 0); },\n\tMA: (q) => { return new ARIMA(0, 0, q); }\n}\n\nconst query = \"SELECT  `TimeStamp`,`currentLuxValue` FROM `GROUP_412` order by `TimeStamp` desc limit 10\";\nlet datalistlenght = 0;\n// TODO train\n\nSearchInAsync(query).then((res) => {\n\n    res = JSON.parse(res.responseText);\n    [idx, val] = extractIdxTensor1D(res);\n\n\n\n    var p = parseInt(GetPluginParameterValue('p_value', 'Selected item'));\n    var d = parseInt(GetPluginParameterValue('d_value', 'Selected item'));\n    var q = parseInt(GetPluginParameterValue('q_value', 'Selected item'));\n\n    mod = new ARIMA(p, d, q);\n    return mod.fit(np.array(val), 8);\n\n  }\n\n).then(res => {\n    DataListgetAsync('class_room_Adel_10').then(results => {\n      datalistlenght = results['result'].length;\n\n      if (datalistlenght == 0) {\n        DataListAddAsync('class_room_Adel_10', JSON.stringify(mod))\n\n        SetPluginParameterValue('Train', 'Caption', 'Trained');\n        SetPluginParameterValue('Flag', 'Color', 'green');\n        DrawPlugin('Train');\n        DrawPlugin('Flag');\n      } else {\n        DataListupdateAsync('class_room_Adel_10', JSON.stringify(mod), 0)\n      }\n      SetPluginParameterValue('Predict', 'Visible', 1);\n      DrawPlugin('Predict');\n      SetPluginParameterValue('Clear', 'Visible', 1);\n      DrawPlugin('Clear');\n    }).then(event.end);\n\n  }\n\n).then(event.end).catch((err) => {\n    // event.error(err);\n  }\n\n);\n// TODO predict\nDataListgetAsync('class_room_Adel_10').then((result) => {\n  model = JSON.parse(result[\"result\"][0]);\n\n  mod = new AutoRegressionIntegratedMovingAverage();\n  mod._initialValue = model._initialValue\n  mod._p = model._p\n  mod._d = model._d\n  mod._q = model._q\n  mod._W = model._W\n  mod._residuals = model._residuals\n  mod._lags = model._lags\n  mod._observationNumber = model._observationNumber\n\n\n  var peridos = parseInt(GetPluginParameterValue('peridos_value', 'Selected item'));\n  return mod.predict(peridos);\n}).then(predictions => {\n  console.log(predictions)\n  // TODO use predictions\n  predictions.forEach(function(item, index) {\n    predictions[index] = parseFloat(item);\n  });\n  SetPluginParameterValue('Pred_list', 'List captions', predictions);\n  SetPluginParameterValue('Pred_list', 'Visible', 1);\n  DrawPlugin('Pred_list');\n  console.log(predictions)\n  event.end();\n}).catch(event.error);"}],"CreatedBy":"h_khair95","CreationDate":"2022-02-06T09:56:45.000Z","IsSaved":true}